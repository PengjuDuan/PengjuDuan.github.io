[{"title":"Pomelo 教程 ---- connector组件源码深度解析","date":"2017-11-22T12:48:42.000Z","path":"2017/11/22/Pomelo-教程-connector组件源码深度解析/","text":"\b\b\b1. 组件分析1.1 什么是connector?\bconnector其实就是Pomelo中的一个组件，俗称前端服务器，\b官方文档中的解释： connector服务器接收客户端的连接请求，创建与客户端的连接，维护客户端的session信息。同时，接收客户端对后端服务器的请求，按照用户配置的路由策略，将请求路由给具体的后端服务器。当后端服务器处理完请求或者需要给客户端推送消息的时候，connector服务器同样会扮演一个中间角色，完成对客户端的消息发送。connector服务器会同时拥有clientPort和port，其中clientPort用来监听客户端的连接，port端口用来给后端提供服务。 \b由此可见，connector组件在pomelo中主要提供的功能有：\b \b负责客户端连接：包含创建连接、\b维护连接、\b\b断开连接等； \b处理请求与响应：\b把客户端的请求转发到后端服务器，把后端服务器的消息推送到客户端； 1.2 为什么要使用connector？\b笔者有过使用socket.io自己搭建实时应用的经历，\b那时我把连接和业务逻辑处理的代码写在一起，虽然也能工作，\b但却不容易拓展。\u001cpomelo的一个核心思想就是分布式，\b把前端服务器（connector组件）与后端服务器（server组件）分开，\bconnector只负责连接，server只负责请求的处理，这样比起前者有了诸多优势： \b易拓展：\b\b前端服务器可以在数量上、连接方式上任意拓展；\b后端服务器\b由于只根据\b输入提供输出，使用场景也不仅限于\bconnector上了，有兴趣的朋友也可以看一下函数计算。\b \b热更新：\b由于前、后端服务器实是在不同的进程之间，当我对后端服务器进行更新时（\b热更新机制后文会详细讲解），\b即使是重启进程，也不影响客户端的连接； 逻辑分区：恰当的分配前、后端服务器，便可以实现逻辑上对用户分区而非物理分区。\b 1.2 如何使用connector？使用connector的方式是非常简单的，只需要在servers.json文件中定义clientPort\b与frontend\b 1234\"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3050, \"clientPort\": 3090, \"frontend\": true, \"args\":\"--inspect=9002\"&#125;, &#123;\"id\": \"connector-server-2\", \"host\": \"127.0.0.1\", \"port\": 3051, \"clientPort\": 3091, \"frontend\": true, \"args\":\"--inspect=9003\"&#125;] 然后在app.js中配置一下connector，那么在pomelo\b启动时就会加载这两个前端服务器12345678app.configure('production|development', 'connector', () =&gt; &#123; app.set('connectorConfig',&#123; connector: pomelo.connectors.hybridconnector, heartbeat: 10, useDict: true, useProtobuf: true, &#125;);&#125;); 本文要着重讲解就是pomelo.connectors.hybridconnector这项配置，这段代码指定了此前端服务器与客户端的连接\b方式，pomelo默认提供了sioconnector和hybridconnector两种连接方式，其中 sioconnector：支持基于socket.io的通讯协议，也是Pomelo框架默认采用的connector（主要是兼容老版本）； hybridconnector：支持socket和websocket，使用二进制通讯协议，并且支持route字典压缩和protobuf压缩； 正如前文所说，connector很容易在数量和连接方式上拓展，那么当你需要时就可以自己写一个connecotr出来。在做这件事情之前，让我们先来分析一下connector的源码。 \b2. connector源码分析2.1 connector初始化与启动connector组件初始化123456789this.connector = getConnector(app, opts);...if (opts.useDict) &#123; app.load(pomelo.dictionary, app.get('dictionaryConfig'));&#125;if (opts.useProtobuf) &#123; app.load(pomelo.protobuf, app.get('protobufConfig'));&#125; 这三行代码对应着app.js里面的配置，而getConnector方法会根据配置加载pomelo内置的hybridconnector或sioconnector实例。 connector组件启动1234pro.afterStart = function(cb) &#123; this.connector.start(cb); this.connector.on('connection', hostFilter.bind(this, bindEvents));&#125;; 其实就是调用了\bthis.connector上的start方法和调用bindEvents方法绑定一些事件，同时生成一个session（关于session相关的信息解读将在后续的博客中讲解）。 那么以hybridconnector为例，我们接着往下看。 hybridconnector.js123456789101112131415161718192021Connector.prototype.start = function(cb) &#123; ... var gensocket = function(socket) &#123; var hybridsocket = new HybridSocket(curId++, socket); hybridsocket.on('handshake', self.handshake.handle.bind(self.handshake, hybridsocket)); hybridsocket.on('heartbeat', self.heartbeat.handle.bind(self.heartbeat, hybridsocket)); hybridsocket.on('disconnect', self.heartbeat.clear.bind(self.heartbeat, hybridsocket.id)); hybridsocket.on('closing', Kick.handle.bind(null, hybridsocket)); self.emit('connection', hybridsocket); &#125;; ... this.switcher.on('connection', function(socket) &#123; gensocket(socket); &#125;); ...&#125;; hybridsocket.js 123456socket.on('message', function(msg) &#123; if(msg) &#123; msg = Package.decode(msg); handler(self, msg); &#125;&#125;); 关于switcher\b暂时可以简单的理解为websocket的连接,\b可以看出来每当\b一个连接建立时，\b都new了一个HybridSocket出来。\b之后，当实例hybridsocket监听到message事件后，也就是接收到了前端发来的请求时，就进入到了pomelo的处理链中。 2.2 connector处理请求的过程即处理链\b继续查看hybridsocket.js与handler.js，不难发现，请求的整个处理过程大致分为以下几个步骤: \b收到消息解码：调用hybridsocket.js上的decode方法，把socket传过来的消息，解码为如下\bjson格式 12345678return &#123; id: xx, // 请求的id route: xx, // 请求的后端服务器路由 body: xx, // 请求体 type: 0, // 请求类型 compressRoute: 0, // 路由压缩 compressGzip: 0, // gzip压缩&#125;; 计算对应的后端服务器： 根据session和第1步解码后的消息dispatch计算出对应的一个后端服务器，然后发起rpc，\b传过去session的\b拷贝和解码后的消息进行调用。 \b\b发送消息编码：\b调用hybridsocket.js上的encode方法，把后端服务器的返回值编码。\b 发送消息: \b调用socket.send方法把编码后的消息发送给客户端。 2.3 \b\bconnector组件源码简单总结 在connector组件中加载\bhybridconnector的实例，\b\b获取引用； \bconnector组件启动时调用hybridconnector.start,\b监听来自客户端的连接； \b每当有新的连接时\bnew一个websocket实例，监听客户端的请求 \b收到客户端请求时，讲消息解码 \b计算对应的后端服务器，并调用获取返回值 对\b后端服务器的返回值编码 调用socket.send方法将编码后的消息发送给客户端 \b相信读到这里，想自定义一个connector已经不是什么难事了，未完待续。","tags":[{"name":"Pomelo","slug":"Pomelo","permalink":"https://github.com/PengjuDuan/tags/Pomelo/"},{"name":"教程","slug":"教程","permalink":"https://github.com/PengjuDuan/tags/教程/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/PengjuDuan/tags/Nodejs/"}]}]